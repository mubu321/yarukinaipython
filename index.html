<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã‚ã‚“ã©ãã•ãŒã‚Šå±‹éãã‚‹python</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      padding: 20px;
      background-color: #2e2e2e;
      color: #e0e0e0;
      max-width: 900px;
      margin: 0 auto;
    }
    textarea {
      width: 100%;
      height: 250px;
      font-family: monospace;
      background-color: #333;
      color: #e0e0e0;
      border: 1px solid #444;
      padding: 10px;
      box-sizing: border-box;
    }
    #output {
      margin-top: 20px;
      background-color: #333;
      color: #e0e0e0;
      padding: 10px;
      white-space: pre-wrap;
      border: 1px solid #444;
      min-height: 150px;
      max-height: 400px;
      overflow-y: auto;
    }
    button {
      background-color: #444;
      color: #e0e0e0;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      margin: 10px 5px 10px 0;
      transition: all 0.3s;
    }
    button:hover {
      background-color: #555;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .controls {
      display: flex;
      align-items: center;
    }
    .laziness-indicator {
      margin-left: 20px;
      display: flex;
      align-items: center;
    }
    .examples-dropdown {
      background-color: #444;
      color: #e0e0e0;
      border: none;
      padding: 8px;
      margin-right: 10px;
    }
    .mood-indicator {
      margin-left: 15px;
      font-size: 24px;
    }
    .highlight {
      background-color: #553355;
    }
    #error-message {
      color: #ff6b6b;
      margin-top: 10px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="header">
    <h2>Python</h2>
    <div class="controls">
      <select id="examples" class="examples-dropdown">
        <option value="">-- ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ --</option>
        <option value="hello">Hello World</option>
        <option value="calc">ç°¡å˜ãªè¨ˆç®—</option>
        <option value="loop">ãƒ«ãƒ¼ãƒ—ã®ä¾‹</option>
        <option value="func">é–¢æ•°ã®ä¾‹</option>
        <option value="list">ãƒªã‚¹ãƒˆã®æ“ä½œ</option>
      </select>
      <div class="laziness-indicator">
        <span>é¢å€’ãã•ã•: </span>
        <span id="laziness-value">1</span>
        <span> / 10</span>
        <span class="mood-indicator" id="mood">ğŸ˜Š</span>
      </div>
    </div>
  </div>
  
  <textarea id="code" placeholder="print('Hello, world!')"></textarea><br>
  <button id="run-btn" onclick="runCode()">å®Ÿè¡Œã™ã‚‹</button>
  <button id="clear-btn" onclick="clearOutput()">ã‚¯ãƒªã‚¢</button>
  <div id="error-message"></div>
  <div id="output"></div>

  <script>
    let variables = {};
    let lists = {};
    let functions = {};
    const complaints = [
      "ã‚ã‚“ã©ãã•ã„", "é•·ã™ãã‚‹", "ã‚„ã‚‹æ°—å‡ºãªã„", "ã¡ã‚‡ã£ã¨ä¼‘ã¾ã›ã¦", "çœ ã„", 
      "ä»Šæ—¥ã¯ç–²ã‚ŒãŸ", "é›£ã—ã™ãã‚‹", "è€ƒãˆãŸããªã„", "ã‚‚ã†ç„¡ç†", "é¢å€’ã ãª",
      "ä»Šæ—¥ã¯ä¼‘æ—¥ã˜ã‚ƒãªã„ï¼Ÿ", "ã‚³ãƒ¼ãƒ‰ãŒå¤šã™ãã‚‹", "ãã“ã¾ã§ã‚„ã‚‹å¿…è¦ã‚ã‚‹ï¼Ÿ"
    ];
    
    const excuses = [
      "çªç„¶çœ ããªã£ãŸ", "é›†ä¸­åŠ›ãŒåˆ‡ã‚ŒãŸ", "ã¡ã‚‡ã£ã¨ä¼‘æ†©ä¸­", "ã‚„ã‚‹æ°—ã‚¹ã‚¤ãƒƒãƒãŒå…¥ã‚‰ãªã„",
      "ã‚³ãƒ¼ãƒ’ãƒ¼ãƒ–ãƒ¬ã‚¤ã‚¯ä¸­", "ã‚¨ãƒ©ãƒ¼ã®ä¿®æ­£ã¯æ˜æ—¥ã‚„ã‚‹", "ä»Šã¨ã¦ã‚‚å¿™ã—ã„"
    ];
    
    const moods = ["ğŸ˜´", "ğŸ˜’", "ğŸ˜", "ğŸ™‚", "ğŸ˜Š"];
    let lazinessLevel = 1;
    
    // å®Ÿè¡Œå›æ•°ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
    let executionCount = 0;
    
    // é¢å€’ãã•ã•ãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
    function updateLazinessLevel() {
      // å®Ÿè¡Œã™ã‚‹ãŸã³ã«é¢å€’ãã•ã•ãŒä¸Šæ˜‡ï¼ˆæœ€å¤§10ï¼‰
      executionCount++;
      lazinessLevel = Math.min(10, Math.ceil(executionCount / 2));
      
      document.getElementById("laziness-value").textContent = lazinessLevel;
      
      // æ°—åˆ†ã®çµµæ–‡å­—ã‚’æ›´æ–°
      const moodIndex = Math.min(Math.floor(lazinessLevel / 2.5), moods.length - 1);
      document.getElementById("mood").textContent = moods[moods.length - 1 - moodIndex];
      
      // é¢å€’ãã•ã•ãŒä¸ŠãŒã‚‹ã«ã¤ã‚Œã¦å®Ÿè¡Œãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å¤‰æ›´
      const runButton = document.getElementById("run-btn");
      if (lazinessLevel <= 3) {
        runButton.textContent = "å®Ÿè¡Œã™ã‚‹";
      } else if (lazinessLevel <= 6) {
        runButton.textContent = "å®Ÿè¡Œã™ã‚‹...";
      } else if (lazinessLevel <= 8) {
        runButton.textContent = "å®Ÿè¡Œã™ã‚‹ï¼ˆãŸã¶ã‚“ï¼‰";
      } else {
        runButton.textContent = "å®Ÿè¡Œã—ã¦ã¿ã‚‹ï¼Ÿ";
      }
    }
    
    // ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰
    const examples = {
      hello: `print('ã“ã‚“ã«ã¡ã¯ã€ä¸–ç•Œï¼')\nname = 'å¤ªéƒ'\nprint('ç§ã®åå‰ã¯' + name + 'ã§ã™')`,
      
      calc: `a = 10\nb = 5\nsum = a + b\nprint('åˆè¨ˆ: ' + sum)\nproduct = a * b\nprint('æ›ã‘ç®—: ' + product)\n\n# å°‘ã—è¤‡é›‘ãªè¨ˆç®—\nresult = (a + b) * 2 - 5\nprint('è¨ˆç®—çµæœ: ' + result)`,
      
      loop: `# forãƒ«ãƒ¼ãƒ—ã®ä¾‹\nfor i in range(1, 6):\n    print('ã‚«ã‚¦ãƒ³ãƒˆ: ' + i)\n\n# whileãƒ«ãƒ¼ãƒ—ã®ä¾‹\ncounter = 0\nwhile counter < 5:\n    print('whileã‚«ã‚¦ãƒ³ãƒˆ: ' + counter)\n    counter = counter + 1`,
      
      func: `# é–¢æ•°å®šç¾©\ndef greet(name):\n    message = 'ã“ã‚“ã«ã¡ã¯ã€' + name + 'ã•ã‚“ï¼'\n    print(message)\n    return message\n\n# é–¢æ•°å‘¼ã³å‡ºã—\ngreet('èŠ±å­')\ngreet('æ¬¡éƒ')`,
      
      list: `# ãƒªã‚¹ãƒˆã®æ“ä½œ\nfruits = ['ã‚Šã‚“ã”', 'ãƒãƒŠãƒŠ', 'ã‚ªãƒ¬ãƒ³ã‚¸']\nprint('ãƒ•ãƒ«ãƒ¼ãƒ„ãƒªã‚¹ãƒˆ:')\nprint(fruits)\n\nfruits.append('ã¶ã©ã†')\nprint('è¿½åŠ å¾Œ:')\nprint(fruits)\n\nprint('æœ€åˆã®æœç‰©: ' + fruits[0])`
    };
    
    document.getElementById("examples").addEventListener("change", function() {
      const selected = this.value;
      if (selected && examples[selected]) {
        document.getElementById("code").value = examples[selected];
      }
    });

    function getRandomComplaint() {
      return complaints[Math.floor(Math.random() * complaints.length)];
    }
    
    function getRandomExcuse() {
      return excuses[Math.floor(Math.random() * excuses.length)];
    }

    function evaluateExpr(expr) {
      try {
        let evaluatedExpr = expr;
        
        // ãƒªã‚¹ãƒˆå‚ç…§ã®å‡¦ç† (ä¾‹: fruits[0])
        const listAccessPattern = /(\w+)\[(\d+)\]/g;
        evaluatedExpr = evaluatedExpr.replace(listAccessPattern, (match, listName, index) => {
          if (lists[listName] && lists[listName][index] !== undefined) {
            return JSON.stringify(lists[listName][index]);
          }
          return match;
        });
        
        // ãƒªã‚¹ãƒˆå…¨ä½“ã®å‚ç…§
        for (let listName in lists) {
          const listRegex = new RegExp('\\b' + listName + '\\b(?!\\[)', 'g');
          evaluatedExpr = evaluatedExpr.replace(listRegex, JSON.stringify(lists[listName]));
        }
        
        // å¤‰æ•°ã®ç½®æ›
        for (let v in variables) {
          const varRegex = new RegExp('\\b' + v + '\\b', 'g');
          evaluatedExpr = evaluatedExpr.replace(varRegex, variables[v]);
        }

        // ãŸã¾ã«æ•°å­—ã‚’ã„ãŸãšã‚‰ã§å¤‰ãˆã‚‹ (10%ã®ç¢ºç‡)
        if (Math.random() < 0.1) {
          evaluatedExpr = evaluatedExpr.replace(/\d+/g, (num) => {
            // å…ƒã®æ•°å€¤ã®Â±20%ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ ã«å¤‰æ›´
            const originalNum = parseInt(num);
            const variance = Math.floor(originalNum * 0.2);
            const newNum = originalNum + Math.floor(Math.random() * variance * 2) - variance;
            return Math.max(0, newNum);
          });
          evaluatedExpr += ' â† æ•°å­—ãŒå‹æ‰‹ã«å¤‰ã‚ã£ãŸã‹ã‚‚';
        }

        // æ–‡å­—åˆ—ã®çµåˆ ('+' æ¼”ç®—å­)
        const stringConcatPattern = /'([^']*)'\s*\+\s*'([^']*)'/g;
        while (stringConcatPattern.test(evaluatedExpr)) {
          evaluatedExpr = evaluatedExpr.replace(stringConcatPattern, "'$1$2'");
        }
        
        // å¤‰æ•°ã¨æ–‡å­—åˆ—ã®çµåˆ
        const varStringConcatPattern = /'([^']*)'\s*\+\s*(\w+)/g;
        evaluatedExpr = evaluatedExpr.replace(varStringConcatPattern, (match, str, varName) => {
          return `'${str}${variables[varName] || varName}'`;
        });
        
        const stringVarConcatPattern = /(\w+)\s*\+\s*'([^']*)'/g;
        evaluatedExpr = evaluatedExpr.replace(stringVarConcatPattern, (match, varName, str) => {
          return `'${variables[varName] || varName}${str}'`;
        });

        // åŸºæœ¬çš„ãªæ•°å­¦æ¼”ç®—ã®è©•ä¾¡
        try {
          // å®‰å…¨ãªå¼ã ã‘è©•ä¾¡
          if (/^[\d\s\+\-\*\/\(\)\.]+$/.test(evaluatedExpr)) {
            return eval(evaluatedExpr);
          }
          
          // æ–‡å­—åˆ—ã‚’è¿”ã™å ´åˆ
          if (evaluatedExpr.startsWith("'") && evaluatedExpr.endsWith("'")) {
            return evaluatedExpr.slice(1, -1);
          }
          
          return evaluatedExpr;
        } catch (e) {
          return evaluatedExpr;
        }
      } catch (error) {
        return `(å¼ã‚¨ãƒ©ãƒ¼: ${error.message})`;
      }
    }

    function shouldIgnore(line) {
      // è¡Œã®é•·ã•ã¨é¢å€’ãã•ã•ãƒ¬ãƒ™ãƒ«ã«åŸºã¥ã„ã¦ç„¡è¦–ã™ã‚‹ç¢ºç‡ã‚’è¨ˆç®—
      const isLong = line.length >= 30;
      const baseChance = isLong ? 0.3 : 0.1;
      
      // ãƒ¬ãƒ™ãƒ«1: ã»ã¨ã‚“ã©ç„¡è¦–ã—ãªã„ã€ãƒ¬ãƒ™ãƒ«10: ã»ã¨ã‚“ã©å…¨éƒ¨ç„¡è¦–
      const lazinessFactor = lazinessLevel / 10;
      
      // é¢å€’ãã•ã•ãŒä¸ŠãŒã‚‹ã»ã©ã€æ€¥æ¿€ã«ç„¡è¦–ã™ã‚‹ç¢ºç‡ãŒä¸Šæ˜‡
      const finalChance = baseChance * Math.pow(lazinessFactor * 1.5, 2);
      
      return Math.random() < finalChance;
    }

    function processListOperation(line) {
      // ãƒªã‚¹ãƒˆä½œæˆ: fruits = ['ã‚Šã‚“ã”', 'ãƒãƒŠãƒŠ']
      const listCreationMatch = line.match(/^(\w+)\s*=\s*\[(.*)\]$/);
      if (listCreationMatch) {
        const listName = listCreationMatch[1];
        const items = listCreationMatch[2].split(',').map(item => {
          item = item.trim();
          if (item.startsWith("'") && item.endsWith("'")) {
            return item.slice(1, -1);
          }
          return evaluateExpr(item);
        });
        lists[listName] = items;
        return `ãƒªã‚¹ãƒˆ ${listName} = [${items.join(', ')}] ã‚’ä½œæˆ`;
      }
      
      // appendæ“ä½œ: fruits.append('ã¶ã©ã†')
      const appendMatch = line.match(/^(\w+)\.append\((.*)\)$/);
      if (appendMatch) {
        const listName = appendMatch[1];
        let item = appendMatch[2].trim();
        
        if (item.startsWith("'") && item.endsWith("'")) {
          item = item.slice(1, -1);
        } else {
          item = evaluateExpr(item);
        }
        
        if (lists[listName]) {
          if (Math.random() < 0.2) {
            // ãŸã¾ã«é–“é•ã£ãŸä½ç½®ã«è¿½åŠ 
            const randomIndex = Math.floor(Math.random() * lists[listName].length);
            lists[listName].splice(randomIndex, 0, item);
            return `${listName} ã®${randomIndex}ç•ªç›®ã« ${item} ã‚’è¿½åŠ ã—ãŸã‹ã‚‚`;
          } else {
            lists[listName].push(item);
            return `${listName} ã« ${item} ã‚’è¿½åŠ `;
          }
        }
        return `ãƒªã‚¹ãƒˆ ${listName} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`;
      }
      
      return null;
    }

    function runCode() {
      const code = document.getElementById("code").value;
      
      // ç©ºã®ã‚³ãƒ¼ãƒ‰ã®å ´åˆã¯ã‚„ã‚‹æ°—ãƒ¬ãƒ™ãƒ«ã‚’ä¸Šã’ãªã„
      if (code.trim() !== '') {
        // é¢å€’ãã•ã•ãƒ¬ãƒ™ãƒ«ã‚’æ›´æ–°
        updateLazinessLevel();
      }
      
      const lines = code.split('\n');
      let output = '';
      variables = {};
      lists = {};
      functions = {};
      let skipBlock = false;
      let insideFunction = false;
      let currentFunc = '';
      let funcArgs = [];
      let funcBody = [];
      document.getElementById("error-message").innerText = '';
      

      
      // å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸã¨ãã®åå¿œ
      // é¢å€’ãã•ã•ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã‚‹ã»ã©å®Ÿè¡Œã‚’æ‹’å¦ã™ã‚‹ç¢ºç‡ãŒä¸ŠãŒã‚‹
      const refusalChance = 0.05 + (lazinessLevel * 0.03);
      if (Math.random() < refusalChance) {
        // é¢å€’ãã•ã•ãŒé«˜ã„ã»ã©æ„šç—´ã‚‚å¤šãè¡¨ç¤º
        let excuse = getRandomExcuse();
        if (lazinessLevel >= 8 && Math.random() < 0.5) {
          excuse += "ã€‚" + getRandomComplaint();
        }
        document.getElementById("error-message").innerText = excuse;
        document.getElementById("output").innerText = '';
        return;
      }

      // ç©ºã®ã‚³ãƒ¼ãƒ‰ã®å ´åˆ
      if (code.trim() === '') {
        document.getElementById("output").innerText = 'ä½•ã‚‚æ›¸ã„ã¦ãªã„ã‚ˆ...';
        return;
      }

      lines.forEach((lineRaw, index) => {
        let line = lineRaw.trim();
        if (line === '' || line.startsWith('#')) return;

        // é–¢æ•°å®šç¾©ã®å‡¦ç†
        if (insideFunction && (lineRaw.startsWith('    ') || lineRaw.startsWith('\t'))) {
          funcBody.push(lineRaw.trim());
          return;
        } else if (insideFunction) {
          functions[currentFunc] = { args: funcArgs, body: funcBody.slice() };
          output += `(é–¢æ•° ${currentFunc} ã‚’è¨˜æ†¶ã—ã¾ã—ãŸ)\n`;
          insideFunction = false;
        }

        // é¢å€’ãã•ã•ã«ã‚ˆã‚‹è¡Œã®ç„¡è¦–
        if (shouldIgnore(line)) {
          let complaint = Math.random() < 0.7 ? ` â† ${getRandomComplaint()}` : '';
          output += `ï¼ˆç„¡è¦–ï¼‰: ${lineRaw}${complaint}\n`;
          return;
        }

        // printæ–‡ã®å‡¦ç†
        if (line.startsWith('print(')) {
          const toPrint = line.match(/print\((.*)\)/);
          if (toPrint) {
            const result = evaluateExpr(toPrint[1]);
            output += `${result}\n`;
          }

        // å¤‰æ•°ä»£å…¥ã®å‡¦ç†
        } else if (line.match(/^\w+\s*=\s*.+$/)) {
          // ãƒªã‚¹ãƒˆæ“ä½œã®ç¢ºèª
          const listResult = processListOperation(line);
          if (listResult) {
            output += `${listResult}\n`;
            return;
          }
          
          const [key, val] = line.split('=').map(s => s.trim());
          variables[key] = evaluateExpr(val);
          output += `${key} = ${variables[key]}\n`;

        // ifæ–‡ã®å‡¦ç†
        } else if (line.startsWith('if ')) {
          const condition = line.slice(3, -1).trim();
          const result = evaluateExpr(condition);
          skipBlock = !result;
          output += `(if ${condition}: ${result ? 'çœŸ' : 'å½'})\n`;

        } else if (line.startsWith('elif ')) {
          if (!skipBlock) {
            // å‰ã®if/elifãŒtrueã ã£ãŸå ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
            skipBlock = true;
          } else {
            const condition = line.slice(5, -1).trim();
            const result = evaluateExpr(condition);
            skipBlock = !result;
            output += `(elif ${condition}: ${result ? 'çœŸ' : 'å½'})\n`;
          }

        } else if (line === 'else:') {
          skipBlock = !skipBlock;
          output += `(else: ${!skipBlock ? 'å®Ÿè¡Œ' : 'ã‚¹ã‚­ãƒƒãƒ—'})\n`;

        // forãƒ«ãƒ¼ãƒ—ã®å‡¦ç†
        } else if (line.match(/^for \w+ in range\(.+\):$/)) {
          const match = line.match(/^for (\w+) in range\((\d+)(?:,\s*(\d+))?\):$/);
          if (match) {
            const varName = match[1];
            const start = match[3] ? parseInt(match[2]) : 0;
            const end = match[3] ? parseInt(match[3]) : parseInt(match[2]);
            
            // é¢å€’ãã•ã•ã«å¿œã˜ã¦ãƒ«ãƒ¼ãƒ—å›æ•°ã‚’åˆ¶é™ï¼ˆé¢å€’ãã•ã•ãŒé«˜ã„ã»ã©å°‘ãªãï¼‰
            const maxIterations = Math.max(2, Math.round(12 - lazinessLevel * 1.2));
            const loopCount = Math.min(end - start, maxIterations);
            
            output += `(forãƒ«ãƒ¼ãƒ— ${varName}, ${start}ã‹ã‚‰${loopCount}å›å®Ÿè¡Œ)\n`;
            
            for (let i = start; i < start + loopCount; i++) {
              variables[varName] = i;
              output += `  ${varName} = ${i}\n`;
            }
            
            if (loopCount < end - start) {
              output += `  ... (æ®‹ã‚Š${end - start - loopCount}å›ã¯é¢å€’ãªã®ã§ã‚¹ã‚­ãƒƒãƒ—)\n`;
            }
          } else {
            output += '(for æ§‹æ–‡ã‚¨ãƒ©ãƒ¼)\n';
          }

        // whileãƒ«ãƒ¼ãƒ—ã®å‡¦ç†
        } else if (line.match(/^while .+:$/)) {
          const condition = line.slice(6, -1).trim();
          let count = 0;
          
          // é¢å€’ãã•ã•ã«å¿œã˜ã¦ãƒ«ãƒ¼ãƒ—å›æ•°ã‚’åˆ¶é™
          const maxIterations = Math.max(1, Math.round(10 - lazinessLevel * 1.1));
          
          while (evaluateExpr(condition) && count < maxIterations) {
            output += `(while å®Ÿè¡Œ: ${count + 1}å›ç›®)\n`;
            count++;
          }
          
          if (evaluateExpr(condition) && count >= maxIterations) {
            output += `(whileãƒ«ãƒ¼ãƒ—ãŒé•·ã„ã®ã§${maxIterations}å›ã§åœæ­¢ã—ã¾ã—ãŸ)\n`;
          }

        // breakæ–‡ã®å‡¦ç†
        } else if (line === 'break') {
          output += '(break ã«ã‚ˆã‚Šãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã¾ã—ãŸ)\n';
          skipBlock = true;

        // continueæ–‡ã®å‡¦ç†
        } else if (line === 'continue') {
          output += '(continue ã«ã‚ˆã‚Šæ¬¡ã®ç¹°ã‚Šè¿”ã—ã¸)\n';

        // é–¢æ•°å®šç¾©ã®å‡¦ç†
        } else if (line.match(/^def \w+\(.*\):$/)) {
          insideFunction = true;
          const funcMatch = line.match(/^def (\w+)\((.*)\):$/);
          currentFunc = funcMatch[1];
          funcArgs = funcMatch[2].split(',').map(arg => arg.trim());
          funcBody = [];
          output += `(é–¢æ•° ${currentFunc} ã®å®šç¾©é–‹å§‹)\n`;

        // é–¢æ•°å‘¼ã³å‡ºã—ã®å‡¦ç†
        } else if (line.match(/^\w+\(.*\)$/)) {
          const callMatch = line.match(/^(\w+)\((.*)\)$/);
          const fname = callMatch[1];
          const args = callMatch[2].split(',').map(a => a.trim());
          
          if (functions[fname]) {
            const params = functions[fname].args;
            const localVars = {};
            const oldVars = {...variables};
            
            // å¼•æ•°ã®å‡¦ç†
            for (let i = 0; i < params.length; i++) {
              const paramValue = i < args.length ? evaluateExpr(args[i]) : undefined;
              localVars[params[i]] = paramValue;
              variables[params[i]] = paramValue;
            }
            
            output += `(é–¢æ•° ${fname} å‘¼ã³å‡ºã—)\n`;
            
            // é–¢æ•°æœ¬ä½“ã®å®Ÿè¡Œï¼ˆé¢å€’ãã•ã•ã«å¿œã˜ã¦ã‚µãƒœã‚‹ç¢ºç‡ä¸Šæ˜‡ï¼‰
            if (Math.random() < 0.15 * lazinessLevel) {  // ãŸã¾ã«ã‚µãƒœã‚‹
              output += `  (é–¢æ•°ã®ä¸­èº«ã¯é¢å€’ãªã®ã§å®Ÿè¡Œã—ã¾ã›ã‚“)\n`;
            } else {
              for (let i = 0; i < functions[fname].body.length; i++) {
                const bodyLine = functions[fname].body[i];
                if (bodyLine.startsWith('print(')) {
                  const toPrint = bodyLine.match(/print\((.*)\)/);
                  if (toPrint) output += `  ${evaluateExpr(toPrint[1])}\n`;
                } else if (bodyLine.startsWith('return ')) {
                  const returnVal = bodyLine.slice(7).trim();
                  output += `  (æˆ»ã‚Šå€¤: ${evaluateExpr(returnVal)})\n`;
                  break;
                } else if (bodyLine.match(/^\w+\s*=\s*.+$/)) {
                  const [key, val] = bodyLine.split('=').map(s => s.trim());
                  variables[key] = evaluateExpr(val);
                  output += `  ${key} = ${variables[key]}\n`;
                }
              }
            }
            
            // ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®çŠ¶æ…‹ã‚’å…ƒã«æˆ»ã™
            variables = {...oldVars};
            
          } else if (fname === 'len' && args.length === 1) {
            // lené–¢æ•°ã®å®Ÿè£…
            const arg = args[0].trim();
            if (lists[arg]) {
              output += `${lists[arg].length}\n`;
            } else {
              output += '(é•·ã•ãŒè¨ˆç®—ã§ãã¾ã›ã‚“)\n';
            }
          } else {
            output += `(é–¢æ•° ${fname} ã¯å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“)\n`;
          }

        // returnæ–‡ã®å‡¦ç†
        } else if (line.match(/^return .+$/)) {
          output += '(é–¢æ•°ã®å¤–ã§returnã¯ä½¿ãˆã¾ã›ã‚“)\n';

        // ãã®ä»–æœªå¯¾å¿œã®æ§‹æ–‡
        } else {
          output += `ï¼ˆæœªå¯¾å¿œã®æ§‹æ–‡ï¼‰: ${lineRaw}\n`;
        }
      });

      document.getElementById("output").innerHTML = highlightOutput(output);
    }
    
    function highlightOutput(text) {
      // ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’é©ç”¨
      return text
        .replace(/(ï¼ˆç„¡è¦–ï¼‰:.*?â†.*?$)/gm, '<span class="highlight">$1</span>')
        .replace(/(\(é–¢æ•°.*?\))/g, '<strong>$1</strong>')
        .replace(/(ã‚¨ãƒ©ãƒ¼|æœªå¯¾å¿œ|è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“)/g, '<span style="color:#ff6b6b">$1</span>');
    }
    
    function clearOutput() {
      document.getElementById("output").innerText = '';
      document.getElementById("error-message").innerText = '';
    }
    

  </script>
</body>
</html>
